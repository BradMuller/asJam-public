package interactive{	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.display.DisplayObjectContainer;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.events.Event;	import interactive.events.DragDropEvent;		public class DraggableItem extends MovieClip{		public static const MAX_MOVE_THRESHOLD:Number = 20;				private var originalParent:DisplayObjectContainer;		private var originalPosition:Point;				private var startPosition:Point;		private var startGlobalCoords:Point;				private var dragTimer:Timer;		public function DraggableItem() {			// constructor code			this.addEventListener( MouseEvent.MOUSE_DOWN, this.onInputBegin );						this.dragTimer = new Timer( 500, 1 );			this.dragTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onDragTimerComplete);		}				public function onInputBegin(event:MouseEvent){			this.dragTimer.start();						this.originalParent = this.parent;			this.originalPosition = new Point(this.x, this.y);						this.startPosition = this.localToGlobal( new Point(0,0) );			this.startGlobalCoords = new Point(event.stageX, event.stageY);						this.stage.addEventListener( MouseEvent.MOUSE_UP, this.onInputEndToCancelDrag, true );			this.stage.addEventListener( MouseEvent.MOUSE_MOVE, this.onInputMoveToPossiblyCancelDrag, true );		}				public function onInputEndToCancelDrag(event:MouseEvent){			cancelDragTimer();		}				public function cancelDragTimer(){			this.stage.removeEventListener( MouseEvent.MOUSE_UP, this.onInputEndToCancelDrag, true );			this.stage.removeEventListener( MouseEvent.MOUSE_MOVE, this.onInputMoveToPossiblyCancelDrag, true );						this.dragTimer.stop();			this.dragTimer.reset();		}				public function onInputMoveToPossiblyCancelDrag(event:MouseEvent){			var currentGlobalCoords:Point = new Point(event.stageX, event.stageY);			var delta:Point = currentGlobalCoords.subtract( this.startGlobalCoords );						if( delta.length > MAX_MOVE_THRESHOLD ){				this.cancelDragTimer();			}		}				public function onDragTimerComplete(event:TimerEvent){			this.stage.removeEventListener( MouseEvent.MOUSE_UP, this.onInputEndToCancelDrag, true );			this.stage.removeEventListener( MouseEvent.MOUSE_MOVE, this.onInputMoveToPossiblyCancelDrag, true );						this.stage.addEventListener( MouseEvent.MOUSE_MOVE, this.onInputMove, true );			this.stage.addEventListener( MouseEvent.MOUSE_UP, this.onInputEnd, true );						var s = this.stage;			this.dispatchEvent( new Event("dragRemoved", true) );			this.x = this.startPosition.x;			this.y = this.startPosition.y;			s.addChild( this );			this.alpha = 0.8;		}				public function onInputMove(event:MouseEvent){			event.stopImmediatePropagation();						var currentGlobalCoords:Point = new Point(event.stageX, event.stageY);			var delta = currentGlobalCoords.subtract( this.startGlobalCoords );						var currentPosition = this.startPosition.add( delta );			this.x = currentPosition.x;			this.y = currentPosition.y;		}				public function onInputEnd(event:MouseEvent){			this.stage.removeEventListener( MouseEvent.MOUSE_MOVE, this.onInputMove, true );			this.stage.removeEventListener( MouseEvent.MOUSE_UP, this.onInputEnd, true );						this.alpha = 1.0;						var dragTargets = stage.getObjectsUnderPoint( new Point(event.stageX, event.stageY) );			for( var i = 0; i < dragTargets.length; i++ ){				var potentialTarget = dragTargets[i];								while( true ){					if( potentialTarget == stage ){						break;					}					if( !(potentialTarget is DisplayObjectContainer) || !potentialTarget.hasEventListener('dragDrop') ){						potentialTarget = potentialTarget.parent;					}else{						potentialTarget.dispatchEvent( new DragDropEvent(this) );						return;					}				}			}			trace("no available drag target!");		}	}	}